<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Δ = THE OBSERVER + Solar-Flare Predictor</title>
  <style>
    body {background:#000;color:#fff;font-family:sans-serif;text-align:center;padding:50px;}
    h1 {font-size:2em;margin-bottom:10px;}
    p {font-size:1.2em;margin:8px 0;}
    button {background:#00f;color:#fff;padding:12px 24px;border:none;border-radius:8px;cursor:pointer;font-size:1.1em;margin:10px 5px;}
    button:disabled {background:#333;cursor:not-allowed;}
    button.flare {background:#b00;}
    #progress {width:250px;height:12px;background:#333;margin:20px auto;border-radius:6px;overflow:hidden;}
    #result {margin-top:20px;white-space:pre-wrap;font-family:monospace;font-size:1.1em;line-height:1.6;}
    .pulse {animation:pulse 1.5s infinite;color:#0f0;text-shadow:0 0 10px #0f0;}
    .pulse-red {animation:pulse-red 1.2s infinite;color:#f55;text-shadow:0 0 12px #f55;}
    @keyframes pulse {0%{opacity:1}50%{opacity:0.5}100%{opacity:1}}
    @keyframes pulse-red {0%{opacity:1}50%{opacity:0.3}100%{opacity:1}}
    #noise-slider {width:250px;margin:20px auto;}
    #noise-value {display:block;margin-top:8px;font-family:monospace;color:#0f0;}
    #flare-status {margin:15px 0;font-family:monospace;color:#ff0;}
    canvas {background:#111;margin:15px auto;display:block;border:1px solid #333;}
  </style>
</head>
<body>
  <h1>Δ = THE OBSERVER</h1>
  <p>Live Bell-State CHSH simulation in a noisy cavity.</p>
  <p>Slide noise, then click to collapse the wavefunction.</p>

  <div>Noise Level (γ): <span id="noise-value">0.005</span></div>
  <input type="range" id="noise-slider" min="0" max="0.1" step="0.001" value="0.005">

  <div id="progress"></div>
  <button id="collapse">Collapse Now</button>
  <button id="predict-flare">Predict Flare</button>

  <div id="flare-status"></div>
  <canvas id="flux-chart" width="400" height="120"></canvas>

  <div id="result"></div>

  <!-- Pyodide + NumPy -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.26.1/full/pyodide.js"></script>
  <script>
    /* -------------------------------------------------
       1. Pyodide initialisation
       ------------------------------------------------- */
    async function initPyodide() {
      let py = await loadPyodide();
      await py.loadPackage("numpy");
      return py;
    }
    const pyReady = initPyodide();

    /* -------------------------------------------------
       2. UI helpers
       ------------------------------------------------- */
    const slider = document.getElementById('noise-slider');
    const noiseVal = document.getElementById('noise-value');
    slider.addEventListener('input', () => noiseVal.textContent = slider.value);

    const collapseBtn = document.getElementById('collapse');
    const predictBtn = document.getElementById('predict-flare');
    const resultDiv = document.getElementById('result');
    const flareDiv = document.getElementById('flare-status');
    const canvas = document.getElementById('flux-chart');
    const ctx = canvas.getContext('2d');

    /* -------------------------------------------------
       3. Bell-state / CHSH simulation (unchanged core)
       ------------------------------------------------- */
    async function runCHSH() {
      const gamma = parseFloat(slider.value);
      collapseBtn.disabled = true; collapseBtn.textContent = "Running…";
      resultDiv.textContent = ""; resultDiv.classList.remove('pulse');

      // fake progress bar
      let w = 0;
      const prog = document.getElementById('progress');
      const iv = setInterval(() => {
        w = (w + 2) % 101;
        prog.style.background = `linear-gradient(to right, #00f ${w}%, #333 ${w}%)`;
      }, 50);

      try {
        const py = await pyReady;
        const code = `
import numpy as np
psi = np.array([1,0,0,1],dtype=complex)/np.sqrt(2)
rho = np.outer(psi,psi.conj())
gamma = ${gamma}
dt = 0.05
steps = 200
for _ in range(steps):
    p = 1-np.exp(-gamma*dt)
    rho[1,1] *= (1-p); rho[2,2] *= (1-p)
    rho[0,0] += p*(rho[1,1]+rho[2,2])
    rho[0,3] *= np.exp(-gamma*dt/2)
    rho[3,0] = rho[0,3].conj()
    rho /= np.trace(rho)
def corr(t1,t2):
    M1 = np.cos(t1)*np.diag([1,-1])+np.sin(t1)*np.array([[0,1],[1,0]])
    M2 = np.cos(t2)*np.diag([1,-1])+np.sin(t2)*np.array([[0,1],[1,0]])
    return np.real(np.trace(np.kron(M1,M2)@rho))
S = corr(0,np.pi/4)+corr(0,-np.pi/4)+corr(np.pi/2,np.pi/4)-corr(np.pi/2,-np.pi/4)
ideal = 2*np.sqrt(2)
loss = (ideal-abs(S))/ideal*100
out = f"CHSH S = {S:.4f} (max 2.828, classical ≤2)\\n"
out += f"Noise Impact: {loss:.1f}% loss\\n\\n"
out += "SPOOKY LINK SURVIVED" if abs(S)>2 else "SPOOKY LINK BROKEN"
print(out)
`;
        await py.runPython(code);
        const output = py.globals.get('out') || py.globals.get('stdout').getvalue();
        clearInterval(iv); prog.style.background = '#333';
        resultDiv.innerText = output;
        if (Math.abs(parseFloat(output.match(/CHSH S = ([-\d.]+)/)[1])) > 2) {
          resultDiv.classList.add('pulse');
        }
      } catch (e) {
        resultDiv.innerText = "Error: " + e.message;
      } finally {
        collapseBtn.textContent = "Collapse Again";
        collapseBtn.disabled = false;
      }
    }

    collapseBtn.addEventListener('click', runCHSH);

    /* -------------------------------------------------
       4. Solar-flare data + tiny predictor
       ------------------------------------------------- */
    let fluxHistory = [];               // [{time, flux}]  (last 30 min)
    let lastPrediction = null;

    async function fetchGOES() {
      // NOAA JSON (1-min cadence, primary satellite)
      const url = 'https://services.swpc.noaa.gov/json/goes/primary/xrays-1-minute.json';
      const resp = await fetch(url);
      const data = await resp.json();
      // keep only the last 30 minutes
      const now = Date.now();
      const thirtyMin = 30*60*1000;
      const recent = data.filter(p => (now - new Date(p.time_tag).getTime()) <= thirtyMin);
      fluxHistory = recent.map(p => ({
        t: new Date(p.time_tag).getTime(),
        f: p.flux   // W/m²
      }));
      drawFluxChart();
    }

    function drawFluxChart() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (fluxHistory.length < 2) return;

      const minT = Math.min(...fluxHistory.map(p=>p.t));
      const maxT = Math.max(...fluxHistory.map(p=>p.t));
      const minF = Math.min(...fluxHistory.map(p=>p.f));
      const maxF = Math.max(...fluxHistory.map(p=>p.f));
      const padX = 30, padY = 20;
      const w = canvas.width - 2*padX, h = canvas.height - 2*padY;

      // axes
      ctx.strokeStyle = '#555';
      ctx.beginPath();
      ctx.moveTo(padX, padY); ctx.lineTo(padX, canvas.height-padY);
      ctx.moveTo(padX, canvas.height-padY); ctx.lineTo(canvas.width-padX, canvas.height-padY);
      ctx.stroke();

      // data line
      ctx.strokeStyle = '#0f0';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      fluxHistory.forEach((p,i) => {
        const x = padX + (p.t - minT)/(maxT-minT)*w;
        const y = canvas.height - padY - (p.f - minF)/(maxF-minF)*h;
        i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
      });
      ctx.stroke();

      // labels
      ctx.fillStyle = '#aaa';
      ctx.font = '10px monospace';
      ctx.fillText('Time →', canvas.width-70, canvas.height-5);
      ctx.fillText('Flux (W/m²) ↑', 5, 15);
    }

    // Very small logistic model: P(flare) = 1/(1+exp(-(w0 + w1*mean + w2*slope)))
    const model = {w0:-8.2, w1:1.8, w2:3.5};   // hand-tuned on a few historical events

    function predictFlareProb() {
      if (fluxHistory.length < 10) return null;
      const fluxes = fluxHistory.map(p=>p.f);
      const mean = fluxes.reduce((a,b)=>a+b)/fluxes.length;
      // simple linear slope over last 5 points
      const recent = fluxes.slice(-5);
      const slope = (recent[recent.length-1] - recent[0]) / (fluxHistory[fluxHistory.length-1].t - fluxHistory[fluxHistory.length-5].t) * 1000; // per second
      const z = model.w0 + model.w1*mean + model.w2*slope;
      return 1/(1+Math.exp(-z));
    }

    async function runFlarePrediction() {
      predictBtn.disabled = true; predictBtn.textContent = "Fetching…";
      flareDiv.textContent = "";
      try {
        await fetchGOES();
        const prob = predictFlareProb();
        lastPrediction = prob;
        const pct = prob ? (prob*100).toFixed(1) : "—";
        flareDiv.textContent = `Flare probability (next ~30 min): ${pct}%`;
        flareDiv.style.color = prob > 0.6 ? '#f55' : '#ff0';
        if (prob > 0.6) collapseBtn.classList.add('pulse-red');
        else collapseBtn.classList.remove('pulse-red');
      } catch (e) {
        flareDiv.textContent = "Error fetching GOES data";
        console.error(e);
      } finally {
        predictBtn.textContent = "Predict Flare";
        predictBtn.disabled = false;
      }
    }

    predictBtn.addEventListener('click', runFlarePrediction);

    // Auto-refresh GOES every 2 min (optional)
    setInterval(fetchGOES, 120000);
    // Initial load
    fetchGOES();
  </script>
</body>
</html>
