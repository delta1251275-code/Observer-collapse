<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Δ = THE OBSERVER</title>
  <style>
    body {
      background: #000;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
      padding: 50px;
    }
    h1 {
      font-size: 2em;
    }
    p {
      font-size: 1.2em;
    }
    button {
      background: #00f;
      color: #fff;
      padding: 10px 20px;
      border: none;
      cursor: pointer;
    }
    #progress {
      width: 200px;
      height: 10px;
      background: #333;
      margin: 20px auto;
    }
    #result {
      margin-top: 20px;
      white-space: pre-wrap;
    }
    .pulse {
      animation: pulse 1.5s infinite;
      color: #0f0;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    #noise-slider {
      width: 200px;
      margin: 20px auto;
    }
    #noise-value {
      display: block;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>Δ = THE OBSERVER</h1>
  <p>Live Bell-State CHSH simulation in a noisy cavity.</p>
  <p>Adjust noise level, then click to collapse the wavefunction.</p>
  
  <label for="noise-slider">Noise Level (0.0 - 0.1):</label>
  <input type="range" id="noise-slider" min="0" max="0.1" step="0.001" value="0.005">
  <span id="noise-value">0.005</span>
  
  <div id="progress"></div>
  <button id="collapse">Collapse Now</button>
  <div id="result"></div>

  <script src="https://cdn.jsdelivr.net/pyodide/v0.26.1/full/pyodide.js"></script>
  <script>
    async function main() {
      let pyodide = await loadPyodide();
      await pyodide.loadPackage("numpy");
      await pyodide.loadPackage("qutip");
      return pyodide;
    }
    let pyodideReadyPromise = main();

    // Update noise value display
    const slider = document.getElementById('noise-slider');
    const noiseValue = document.getElementById('noise-value');
    slider.addEventListener('input', () => {
      noiseValue.textContent = slider.value;
    });

    async function runSimulation() {
      // Get current noise from slider
      const noise_level = parseFloat(slider.value);

      // Simple progress bar animation (runs independently)
      const progress = document.getElementById('progress');
      progress.style.background = 'linear-gradient(to right, #00f 0%, #333 100%)';
      let width = 0;
      const interval = setInterval(() => {
        width = (width + 1) % 100;
        progress.style.background = `linear-gradient(to right, #00f ${width}%, #333 ${width}%)`;
      }, 50);

      let pyodide = await pyodideReadyPromise;
      let pythonCode = `
import qutip as qt
import numpy as np
from numpy.random import choice

def get_projectors(M):
    e, v = M.eigenstates()
    if e[1] == 1:
        Pplus = v[1] * v[1].dag()
        Pminus = v[0] * v[0].dag()
    else:
        Pplus = v[0] * v[0].dag()
        Pminus = v[1] * v[1].dag()
    return Pplus, Pminus

def get_correlation(rho, M1, M2, trials):
    P1plus, P1minus = get_projectors(M1)
    P2plus, P2minus = get_projectors(M2)
    p_pp = (qt.tensor(P1plus, P2plus) * rho).tr().real
    p_pm = (qt.tensor(P1plus, P2minus) * rho).tr().real
    p_mp = (qt.tensor(P1minus, P2plus) * rho).tr().real
    p_mm = (qt.tensor(P1minus, P2minus) * rho).tr().real
    total = p_pp + p_pm + p_mp + p_mm
    if total > 0:
        p_pp /= total
        p_pm /= total
        p_mp /= total
        p_mm /= total
    outcomes = choice(['++', '+-', '-+', '--'], size=trials, p=[p_pp, p_pm, p_mp, p_mm])
    corr = (np.sum(outcomes == '++') + np.sum(outcomes == '--') - np.sum(outcomes == '+-') - np.sum(outcomes == '-+')) / trials
    return corr

def compute_chsh(rho, num_trials=5000):
    def get_meas_op(theta):
        return np.cos(theta) * qt.sigmaz() + np.sin(theta) * qt.sigmax()
    theta_a = 0
    theta_ap = np.pi/2
    theta_b = np.pi/4
    theta_bp = -np.pi/4
    A = get_meas_op(theta_a)
    Ap = get_meas_op(theta_ap)
    B = get_meas_op(theta_b)
    Bp = get_meas_op(theta_bp)
    trials_per = num_trials // 4
    ab = get_correlation(rho, A, B, trials_per)
    abp = get_correlation(rho, A, Bp, trials_per)
    apb = get_correlation(rho, Ap, B, trials_per)
    apbp = get_correlation(rho, Ap, Bp, trials_per)
    s = ab + abp + apb - apbp
    return s

psi0 = qt.bell_state('00')
rho0 = psi0 * psi0.dag()
H = qt.Qobj(np.zeros((4,4)), dims=[[2,2],[2,2]])
extra_noise = 0.0  # Adjust if needed
noise_level = ${noise_level} + extra_noise  # Use slider value
c_ops = [np.sqrt(noise_level) * qt.tensor(qt.sigmam(), qt.qeye(2)), np.sqrt(noise_level) * qt.tensor(qt.qeye(2), qt.sigmam())]
tlist = np.linspace(0, 0.5, 10)  # Short time for low decoherence
result = qt.mesolve(H, rho0, tlist, c_ops)
rho = result.states[-1]
s = compute_chsh(rho)
ideal = 2 * np.sqrt(2)
loss = (ideal - abs(s)) / ideal * 100
output = f"CHSH Value (S): {s:.4f}\\nNoise Impact: {loss:.1f}% loss"
if abs(s) > 2:
    output += "\\nSPOOKY LINK SURVIVED"
else:
    output += "\\nSPOOKY LINK BROKEN"
print(output)
`;
      let output = await pyodide.runPython(pythonCode);
      clearInterval(interval);
      progress.style.background = '#333';  // Reset progress
      const resultDiv = document.getElementById('result');
      resultDiv.innerText = output;
      if (Math.abs(parseFloat(output.split('\\n')[0].split(': ')[1])) > 2) {
        resultDiv.classList.add('pulse');
      } else {
        resultDiv.classList.remove('pulse');
      }
    }
    document.getElementById('collapse').addEventListener('click', runSimulation);
  </script>
</body>
</html>
